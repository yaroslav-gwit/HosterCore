package main

import (
	"HosterCore/internal/app/rest_api_v2/pkg/handlers"
	MiddlewareLogging "HosterCore/internal/app/rest_api_v2/pkg/middleware/logging"
	FreeBSDLogger "HosterCore/internal/pkg/freebsd/logger"
	"net/http"
	"os"
	"time"

	"github.com/gorilla/mux"
	"github.com/sirupsen/logrus"
	_ "github.com/swaggo/http-swagger/example/gorilla/docs" // docs is generated by Swag CLI, you have to import it.
	httpSwagger "github.com/swaggo/http-swagger/v2"
)

var logInternal = logrus.New()
var log *MiddlewareLogging.Log

func init() {
	logStdOut := os.Getenv("LOG_STDOUT")
	logFile := os.Getenv("LOG_FILE")

	// Log as JSON instead of the default ASCII/text formatter.
	// log.SetFormatter(&logrus.JSONFormatter{})

	// Output to stdout instead of the default stderr
	logInternal.SetOutput(os.Stdout)

	// Log to file, but fallback to STDOUT if something goes wrong
	if logStdOut == "false" && len(logFile) > 2 {
		file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
		if err != nil {
			FreeBSDLogger.LoggerToSyslog(FreeBSDLogger.LOGGER_SRV_SCHEDULER, FreeBSDLogger.LOGGER_LEVEL_ERROR, "DNS_SERVER: could not use this file for logging "+logFile+", falling back to STDOUT")
		} else {
			logInternal.SetOutput(file)
		}
	}

	logInternal.SetLevel(logrus.DebugLevel)
	logInternal.SetReportCaller(true)
}

// var log *MiddlewareLogging.Log

// @title Hoster REST API Docs (FreeBSD backend REST API)
// @version 2.0
// @description REST API documentation for the backend `Hoster` servers.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @BasePath /api/v2
func main() {
	// log = MiddlewareLogging.Configure(logrus.DebugLevel)
	r := mux.NewRouter()
	// Swagger docs
	r.PathPrefix("/api/v2/swagger/").Handler(httpSwagger.Handler(
		httpSwagger.URL("/api/v2/swagger.json"), //The url pointing to API definition
		httpSwagger.DeepLinking(true),
		httpSwagger.DocExpansion("none"),
		httpSwagger.DomID("swagger-ui"),
	)).Methods(http.MethodGet)
	// Define a route to serve the static file
	r.HandleFunc("/api/v2/swagger.json", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "docs/swagger.json")
	})

	// Health checks
	r.HandleFunc("/api/v2/health", handlers.HealthCheck).Methods("GET")
	r.HandleFunc("/api/v2/health/auth", handlers.HealthCheck).Methods("GET")
	r.HandleFunc("/api/v2/health/ha-auth", handlers.HealthCheck).Methods("GET")

	// Middleware -> Logging
	log = MiddlewareLogging.Configure(logrus.DebugLevel)
	handlers.SetLogConfig(log)
	r.Use(log.LogResponses)

	http.Handle("/", r)
	srv := &http.Server{
		// Handler: r,
		Addr: "0.0.0.0:4000",
		// Good practice: enforce timeouts for servers you create!
		WriteTimeout: 5 * time.Second,
		ReadTimeout:  5 * time.Second,
	}
	err := srv.ListenAndServe()
	if err != nil {
		logInternal.Fatal("could not start the REST API server: " + err.Error())
	}
}
